/**
 * Appcelerator Titanium Mobile
 * Copyright (c) 2009-2019 by Axway. All Rights Reserved.
 * Licensed under the terms of the Apache Public License.
 * Please see the LICENSE included with this distribution for details.
 */
import { promisify } from 'util';
import { exec as execSync } from 'child_process'; // eslint-disable-line security/detect-child-process
import fs from 'fs-extra';
import path from 'path';
import ejs from 'ejs';
import generateBootstrap from './genBootstrap.js';
import { fileURLToPath } from 'url';
import Builder from '../../build/lib/builder.mjs';
import Android from '../../build/lib/android/index.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const exec = promisify(execSync);
const runtimeV8DirPath = path.join(__dirname, '..', 'runtime', 'v8');

// Determine if we're running on a Windows machine.
const isWindows = process.platform === 'win32';

/**
 * Double quotes given path and escapes double quote characters in file/directory names.
 * @param {String} filePath The path to be double quoted.
 * @return {String} Returns the double quoted path.
 */
function quotePath(filePath) {
	if (!filePath) {
		return '""';
	}
	if (!isWindows) {
		filePath = filePath.replace(/"/g, '\\"');
	}
	return `"${filePath}"`;
}

/**
 * Executes the "gperf" command line tool used to generate a C/C++ file with perfect hashes.
 * @param {String} workingDirPath The directory which all paths will be relative to. Cannot be null.
 * @param {String} inputFilePath Path to the C/C++ file template used to generate the output file with perfect hashes.
 * @param {String} outputFilePath File name and path to the file to be generated by the gperf tool.
 */
async function gperf(workingDirPath, inputFilePath, outputFilePath) {
	// Acquire a path to the "gperf" command line tool.
	let gperfPath = 'gperf';
	if (isWindows) {
		gperfPath = quotePath(path.join(__dirname, '..', '..', 'build', 'win32', 'gperf'));
	}

	// Run the "gperf" command.
	const commandLine = gperfPath + ' -L C++ -E -t ' + quotePath(inputFilePath);
	const { stdout, stderr } = await exec(commandLine, { cwd: workingDirPath });
	if (stderr) {
		throw new Error(`"gperf" failed to process file "${inputFilePath}". Reason: ${stderr}`);
	}
	await fs.writeFile(outputFilePath, stdout);
}

/**
 * @param {string} outputDir directory to place the generated 'ti.kernel.js' file
 */
async function generateTiKernel(outputDir) {
	const options = { };
	const builder = new Builder(options, [ 'android' ]);
	await builder.ensureGitHash();
	const sdkVersion = (await fs.readJson(new URL('../../package.json', import.meta.url))).version;
	const android = new Android({
		sdkVersion,
		gitHash: options.gitHash,
		timestamp: options.timestamp
	});

	return builder.generateKernelBundle('android', android.babelOptions(), outputDir);
}

/**
 * Generate a C int array for baking bytes in c header files
 * @param {Buffer} data the bytes from an input JS file
 * @returns {string} the generated bytes as a string
 */
function bufferToCIntArray(data) {
	const indent = '    ';
	let position = 0;
	const split = 30;
	const length = data.length;
	const output = [];
	for (let i = 0; i < length; ++i, ++position) {
		if ((position % split) === 0) {
			output.push('\n' + indent);
		}
		if (position > 0) {
			output.push(',');
		}
		output.push(data.readInt8(i));
	}
	output.push(',0'); // NULL termination
	return output.join('').trim();
}

/**
 * @param {string} headerFilepath the C header to output
 * @param {Map<string, string>} inputFiles the mapping from expected name to JS file to process as input
 */
async function js2c(headerFilepath, inputFiles) {
	const sources = {};
	for (let [ name, file ] of inputFiles) {
		const data = bufferToCIntArray(await fs.readFile(file));
		sources[name] = data;
	}

	const headerTemplate = await fs.readFile(path.join(__dirname, 'KrollJS.h.ejs'), 'utf8');
	const fileContent = ejs.render(headerTemplate, {
		sources
	});
	return fs.writeFile(headerFilepath, fileContent);
}

/**
 * Overwrite "outFile" with "inFile" if file content is different and then removes "inFile".
 * Intended to improve incremental build times by only updating files if they've actually changed.
 * @param {string} inFile Path to the file intended to replace the "outFile".
 * @param {string} outFile Ptah to the destination file to be replaced. Does not have to exist.
 */
async function replaceFileIfDifferent(inFile, outFile) {
	// Do not continue if the 2 files have the same content.
	if (await fs.exists(outFile)) {
		const inFileContent = await fs.readFile(inFile);
		const outFileContent = await fs.readFile(outFile);
		if (inFileContent.toString() === outFileContent.toString()) {
			return fs.unlink(inFile);
		}
	}

	// Move file to destination. Will overwrite if destination already exists.
	return fs.rename(inFile, outFile);
}

/**
 * Generate a "KrollNativeBindings.h" file with perfect hashes via gperf tool.
 * @param {string} outDir dir to place generated KrollNativeBindings.h file
 */
async function generateKrollNativeBindings(outDir) {
	// Note: 2nd argument is inserted into file as-is. Use relative path since absolute may contain user name.
	const headerFilePath = path.join(outDir, 'KrollNativeBindings.h');
	const tempFilePath = headerFilePath + '.temp';
	await gperf(runtimeV8DirPath, 'src/native/KrollNativeBindings.gperf', tempFilePath);
	return replaceFileIfDifferent(tempFilePath, headerFilePath);
}

async function generateBootstrapAndKrollGeneratedBindings(outDir) {
	// Generate "bootstrap.js" and "KrollGeneratedBindings.gperf" files.
	await generateBootstrap(outDir);

	// Generate a "KrollGeneratedBindings.h" file with perfect hashes via gperf tool.
	// Note: 2nd argument is inserted into file as-is. Use relative path since absolute may contain user name.
	const headerFilePath = path.join(outDir, 'KrollGeneratedBindings.h');
	const tempFilePath = headerFilePath + '.temp';
	await gperf(runtimeV8DirPath, 'generated/KrollGeneratedBindings.gperf', tempFilePath);
	return replaceFileIfDifferent(tempFilePath, headerFilePath);
}

/** Generates C/C++ source files containing internal JS files and from gperf templates. */
async function generateSourceCode() {
	const outDir = path.join(runtimeV8DirPath, 'generated');
	const kernelOutDir = path.join(__dirname, 'build/outputs/ti-assets/Resources');
	await fs.mkdirs(outDir);
	await Promise.all([
		generateKrollNativeBindings(outDir),
		generateBootstrapAndKrollGeneratedBindings(outDir),
		// Generate a rolled up bundle of ti.kernel.js
		generateTiKernel(kernelOutDir),
	]);
	// Generate a "KrollJS.h" file containing bootstrap.js and ti.kernel.js (as "kroll")
	const files = new Map();
	files.set('bootstrap', path.join(outDir, 'bootstrap.js'));
	files.set('kroll', path.join(kernelOutDir, 'ti.kernel.js'));
	const headerFilePath = path.join(outDir, 'KrollJS.h');
	const tempFilePath = headerFilePath + '.temp';
	await js2c(tempFilePath, files);
	return replaceFileIfDifferent(tempFilePath, headerFilePath);
}

/** Executes the pre-build step. */
async function main() {
	console.log('Running Titanium "prebuild.mjs" script.');
	// Generate C/C++ source files with JS files embedded in them and from gperf templates.
	return generateSourceCode();
}

main()
	.then(() => process.exit(0))
	.catch((err) => {
		console.error(err);
		process.exit(1);
	});

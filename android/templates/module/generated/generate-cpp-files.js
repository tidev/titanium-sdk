/**
 * TiDev Titanium Mobile
 * Copyright TiDev, Inc. 04/07/2022-Present
 * Licensed under the terms of the Apache Public License.
 * Please see the LICENSE included with this distribution for details.
 */

'use strict';

console.log('Running Titanium "generate-cpp-files.js" script.');

// --- WARNING ---
// We should only require-in core modules here, because this script is executed by the module's "build.gradle" file.
// Can't assume a "node_modules" folder is available and we want to support building via Android Studio for debugging.
const fs = require('fs');
const path = require('path');

// The default kroll namespace.
const Kroll_DEFAULT = 'org.appcelerator.kroll.annotations.Kroll.DEFAULT';

/**
 * Replaces all "${name}" placeholders in given "text" string matching the given dictionary
 * of placeholder name/value pairs.
 * @param {String} text The string containing the placeholders
 * @param {{name: {String}, value: {String}}} placeholders
 * Dictionary of placeholder name/value string pairs to do the replacement with.
 * @returns {String}
 * The string with all given placeholders replaced.
 * Reference will match given "text" argument if no replacements were performed.
 */
function replacePlaceholders(text, placeholders) {
	// Do not continue if given an invalid text argument or it's an empty string.
	if ((typeof text !== 'string') || (text.length <= 0)) {
		return text;
	}

	// Argument must be a dictionary of name/value pairs.
	if (typeof placeholders !== 'object') {
		return text;
	}

	// Replace all ${placeholder} strings using given dictionary.
	for (const placeholderName in placeholders) {
		// Fetch the placeholder name/value pair.
		if (typeof placeholderName !== 'string') {
			continue;
		}
		let placeholderValue = placeholders[placeholderName];
		if ((placeholderValue === null) || (typeof placeholderValue === 'undefined')) {
			placeholderValue = '';
		}

		// Replace all placeholders having given name.
		// eslint-disable-next-line security/detect-non-literal-regexp
		const regexObject = new RegExp('\\$\\{' + placeholderName + '\\}', 'g');
		text = text.replace(regexObject, placeholderValue.toString());
	}
	return text;
}

/** Generates C++ source files for the module. */
async function main() {
	// Load module's JSON file containing all proxy bindings generated by "kroll-apt" Java annotatation processor.
	const bindingJsonPath = process.env.TI_MODULE_BINDINGS_JSON_FILE;
	const bindingJson = JSON.parse(fs.readFileSync(bindingJsonPath));
	const moduleClassName = Object.keys(bindingJson.modules)[0];
	const moduleName = bindingJson.modules[moduleClassName]['apiName'];

	const moduleNamespace = process.env.TI_MODULE_NAMESPACE;
	const modulesWithCreate = [];
	const apiTree = {};
	const initTable = [];
	let headers = '';
	let globalsJS = '';
	let invocationJS = '';

	function getParentModuleClass(proxyMap) {
		let name;
		const proxyAttrs = proxyMap['proxyAttrs'];

		if (proxyAttrs['creatableInModule'] && (proxyAttrs['creatableInModule'] !== Kroll_DEFAULT)) {
			name = proxyAttrs['creatableInModule'];
		} else if (proxyAttrs['parentModule'] && (proxyAttrs['parentModule'] !== Kroll_DEFAULT)) {
			name = proxyAttrs['parentModule'];
		}
		return name;
	}

	function getFullApiName(proxyMap) {
		let fullApiName = proxyMap['proxyAttrs']['name'];
		let parentModuleClass = getParentModuleClass(proxyMap);

		while (parentModuleClass) {
			const parent = bindingJson.proxies[parentModuleClass];
			fullApiName = parent['proxyAttrs']['name'] + '.' + fullApiName;
			parentModuleClass = getParentModuleClass(parent);
		}

		return fullApiName;
	}

	function processNode(node, namespace, indent) {
		const childAPIs = Object.keys(node);

		// ignore _dependencies and _className in the childAPIs count
		const hasChildren = childAPIs.filter((api) => {
			return ([ '_className', '_dependencies' ].indexOf(api) === -1);
		}).length > 0;

		const className = node['_className'];
		const proxyMap = bindingJson['proxies'][className];
		const isModule = proxyMap['isModule'];
		const hasCreateProxies = (isModule && ('createProxies' in bindingJson['modules'][className]));

		let js = '';
		if (('_dependencies' in node) && ((node['_dependencies'].length) > 0)) {
			node['_dependencies'].forEach((dependency, index) => {
				js += `// Ensure ${dependency} is initialized\n`;
				js += ` var dep${index} = module.${dependency};\n`;
			});
		}

		let apiName = namespace.split('.');
		let varName;
		let decl;
		if (apiName[0] === '') {
			varName = 'module';
			namespace = moduleName;
			apiName = moduleName;
			decl = '';
		} else {
			apiName = apiName[apiName.length - 1];
			varName = apiName;
		}

		if (hasCreateProxies) {
			if (!(apiName in modulesWithCreate)) {
				modulesWithCreate.push(namespace);
			}
		}

		const invocationAPIs = [];
		if ('methods' in proxyMap) {
			for (const method of Object.keys(proxyMap.methods)) {
				const methodMap = proxyMap.methods[method];
				if (methodMap.hasInvocation) {
					invocationAPIs.push(methodMap);
				}
			}
		}

		if ('dynamicProperties' in proxyMap) {
			for (const dp of Object.keys(proxyMap.dynamicProperties)) {
				const dpMap = proxyMap.dynamicProperties[dp];
				if (dpMap.getHasInvocation) {
					invocationAPIs.push({ apiName: dpMap.getMethodName });
				}
				if (dpMap.setHasInvocation) {
					invocationAPIs.push({ apiName: dpMap.setHasInvocation });
				}
			}
		}

		const hasInvocationAPIs = (invocationAPIs.length > 0);
		const needsReturn = hasChildren || hasCreateProxies || hasInvocationAPIs || true;

		if (namespace !== moduleName) {
			decl = 'var ' + varName + ' = ';
			if (!needsReturn) {
				decl = 'return';
			}
			js += `${decl} lazyGet(this, "${className}", "${apiName}", "${namespace}");\n`;
		}

		let childJS = '';
		for (const childAPI of childAPIs) {
			if ([ '_className', '_dependencies' ].indexOf(childAPI) === -1) {
				let childNamespace = namespace + '.' + childAPI;
				if (namespace === moduleName) {
					childNamespace = childAPI;
				}

				childJS += `"${childAPI}": {\nget: function() {\n`;
				childJS += processNode(node[childAPI], childNamespace, indent + 1);
				childJS += '},\nconfigurable: true\n},\n';
			}
		}

		if (hasChildren) {
			js += `\tif (!("__propertiesDefined__" in ${varName})) {`;
			js += `Object.defineProperties(${varName}, {\n${childJS}\n});\n`;
		}

		if (hasCreateProxies) {
			const createProxies = bindingJson.modules[className].createProxies;
			createProxies.forEach(function (create) {
				const accessor = '["' + create.name + '"]';
				invocationAPIs.push({ apiName: 'create' + create.name });
				js += `${varName}.constructor.prototype.create${create.name} = function() {\nreturn new ${varName}${accessor}(arguments);\n}\n`;
			});
		}

		if (hasChildren) {
			js += '}\n';
			js += varName + '.__propertiesDefined__ = true;\n';
		}

		if ('topLevelMethods' in proxyMap) {
			Object.keys(proxyMap.topLevelMethods).forEach(function (method) {
				var ns = namespace.indexOf('Titanium') !== 0 ? 'Ti.' + namespace : namespace,
					topLevelNames = proxyMap.topLevelMethods[method];

				topLevelNames.forEach(function (name) {
					globalsJS += `global.${name} = function() {\nreturn ${ns}.${method}.apply(${ns}, arguments);\n}\n`;
				});

			});
		}

		invocationAPIs.forEach(function (api) {
			invocationJS += `addInvocationAPI(module, "${moduleName}", "${namespace}", "${api['apiName']}");`;
		});

		if (needsReturn) {
			js += 'return ' + varName + ';\n';
		}

		return js;
	} // end processNode

	for (const proxy of Object.keys(bindingJson.proxies)) {
		const fullApi = getFullApiName(bindingJson.proxies[proxy]);
		let tree = apiTree;

		// apiTree
		for (const api of fullApi.split('.')) {
			if (api !== moduleName && !(api in tree)) {
				tree[api] = {
					_dependencies: []
				};
				tree = tree[api];
			}
		}
		tree['_className'] = proxy;

		// initTable
		const namespaces = fullApi.split('.').slice(0, -1).map((s) => {
			return s.toLowerCase();
		});

		if (namespaces.indexOf(moduleNamespace) === -1) {
			namespaces.unshift(moduleNamespace.split('.').join('::'));
		}

		const namespace = namespaces.join('::');
		let className = bindingJson.proxies[proxy]['proxyClassName'];
		// If the class name doesn't have the module namespace, prepend it
		if (className.indexOf(namespace) !== 0) {
			className = namespace + '::' + className;
		}
		headers += '#include "' + proxy + '.h"\n';
		const initFunction = '::' + className + '::bindProxy';
		const disposeFunction = '::' + className + '::dispose';

		initTable.unshift('{' + [ '"' + proxy + '"', initFunction, disposeFunction ].join(', ').toString() + '}');
	}

	const bootstrapJS = processNode(apiTree, '', 0);

	// Module's "build.gradle" file passes info to this script via the following environment variables.
	const moduleId = process.env.TI_MODULE_ID;
	const sdkModuleTemplateDirPath = process.env.TI_MODULE_TEMPLATE_DIR;
	const outputJniDirPath = process.env.TI_MODULE_GENERATED_JNI_DIR;
	const outputJavaScriptDirPath = process.env.TI_MODULE_GENERATED_JS_DIR;

	// Make sure output directories exist before generating files under them.
	fs.mkdirSync(outputJniDirPath, { recursive: true });
	fs.mkdirSync(outputJavaScriptDirPath, { recursive: true });

	// Generate C++ file used to load module's kroll annotation generated bindings.
	let fileContent = fs.readFileSync(path.join(sdkModuleTemplateDirPath, 'TiModuleBootstrap.cpp'));
	fileContent = replacePlaceholders(fileContent.toString(), {
		moduleId: moduleId,
		jniPackage: moduleId.replace(/\./g, '_')
	});
	fs.writeFileSync(path.join(outputJniDirPath, 'TiModuleBootstrap.cpp'), fileContent);

	// Create JavaScript file which generates proxy create() methods and "invocation" relative path handling methods.
	fileContent = fs.readFileSync(path.join(sdkModuleTemplateDirPath, 'bootstrap.js'));
	fileContent = replacePlaceholders(fileContent.toString(), {
		globalsJS: globalsJS,
		invocationJS: invocationJS,
		bootstrapJS: bootstrapJS,
		modulesWithCreate: modulesWithCreate,
		moduleClass: apiTree['_className'],
		moduleName: moduleName
	});
	const jsBootstrapFilePath = path.join(outputJavaScriptDirPath, 'bootstrap.js');
	fs.writeFileSync(jsBootstrapFilePath, fileContent);

	// Generate a C++ header file mapping JavaScript APIs to genereated V8 C++ class APIs.
	fileContent = fs.readFileSync(path.join(sdkModuleTemplateDirPath, 'KrollGeneratedBindings.h'));
	fileContent = replacePlaceholders(fileContent.toString(), {
		bindingArrayEntries: initTable.join(',\n\t\t\t\t'),
		bindingMapEntries: initTable.reduce((mapEntries, table, index) => {
			mapEntries.push(`{binds[${index}].name, binds[${index}]}`);
			return mapEntries;
		}, []).join(',\n\t\t\t\t'),
		headers: headers
	});
	fs.writeFileSync(path.join(outputJniDirPath, 'KrollGeneratedBindings.h'), fileContent);

	// Create a C++ header file storing the above generated "bootstrap.js" as an array of bytes.
	const charArray = [];
	const jsBuffer = Buffer.from(fs.readFileSync(jsBootstrapFilePath));
	[].forEach.call(jsBuffer, (char) => {
		charArray.push(char);
	});
	charArray.push('0');
	fileContent = fs.readFileSync(path.join(sdkModuleTemplateDirPath, 'BootstrapJS.h'));
	fileContent = replacePlaceholders(fileContent.toString(), {
		id: 'bootstrap',
		data: charArray.join(', ')
	});
	fs.writeFileSync(path.join(outputJniDirPath, 'BootstrapJS.h'), fileContent);
}

main()
	.then(() => process.exit(0))
	.catch((err) => {
		console.error(err);
		process.exit(1);
	});
